<?php
/*

    MERGED APPMONITOR CLIENT :: WORK IN PROGRESS

    generated Fri Feb 28 11:50:56 CET 2025

*/

 class checkApacheProcesses extends appmonitorcheck { protected string $_sServerStatusUrl = 'http://localhost/server-status'; protected float $_iWarn = 50; protected float $_iError = 75; public function explain(): array { return [ 'name' => 'Plugin ApacheProcesses', 'descriptionm' => 'Check count running Apache processes', 'parameters' => [ 'url' => [ 'type' => 'string', 'required' => false, 'decsription' => 'Override https server-status page; default is http://localhost/server-status; Use it if the protocol to localhost is not http, but https or if it requires an authentication', 'default' => $this->_sServerStatusUrl, 'example' => '', ], 'warning' => [ 'type' => 'float', 'required' => false, 'decsription' => 'Limit to switch to warning (in percent)', 'default' => $this->_iWarn, 'example' => 30, ], 'error' => [ 'type' => 'float', 'required' => false, 'decsription' => 'Limit to switch to critical (in percent)', 'default' => $this->_iError, 'example' => 50, ], ], ]; } protected function _getApacheProcesses(): bool|array { $sBody = file_get_contents($this->_sServerStatusUrl); if (!$sBody) { return false; } $sRegexScoreboard = '/<pre>(.*)\<\/pre\>/U'; $aScore = []; $sStatusNobr = str_replace("\n", "", $sBody); if (preg_match_all($sRegexScoreboard, $sStatusNobr, $aTmpTable)) { $sScoreString = $aTmpTable[1][0]; $aScore['total'] = strlen($sScoreString); $aScore['free'] = substr_count($sScoreString, '.'); $aScore['waiting'] = substr_count($sScoreString, '_'); $aScore['active'] = $aScore['total'] - $aScore['free'] - $aScore['waiting']; } return $aScore; } public function getGroup(): string { return 'monitor'; } public function run(array $aParams): array { if (isset($aParams['url']) && $aParams['url']) { $this->_sServerStatusUrl = $aParams['url']; } if (isset($aParams['warning']) && (int) $aParams['warning']) { $this->_iWarn = (int) $aParams['warning']; } if (isset($aParams['error']) && (int) $aParams['error']) { $this->_iError = (int) $aParams['error']; } $aProcesses = $this->_getApacheProcesses(); $iActive = $aProcesses ? $aProcesses['active'] : false; if ($iActive === false) { $iResult = RESULT_UNKNOWN; } else { $sComment = ''; $iTotal = $aProcesses['total']; $iResult = RESULT_OK; if (($iActive / $iTotal * 100) > $this->_iWarn) { $iResult = RESULT_WARNING; $sComment = "more than warning level $this->_iWarn %"; } else { $sComment = "less than warning level $this->_iWarn %"; } if (($iActive / $iTotal * 100) > $this->_iError) { $iResult = RESULT_ERROR; $sComment = "more than error level $this->_iError %"; } } return [ $iResult, ($iActive === false ? 'Apache httpd server status is not available' : 'apache processes: ' . print_r($aProcesses, 1)) . ' ' . $sComment, ($iActive === false ? [] : [ 'type' => 'counter', 'count' => $iActive, 'visual' => 'line', ] ) ]; } } 
 class checkCert extends appmonitorcheck { public function getGroup(): string { return 'security'; } public function run(array $aParams): array { $sUrl = $aParams["url"] ?? 'http' . ($_SERVER['HTTPS'] ? 's' : '') . '://' . $_SERVER['SERVER_NAME'] . ':' . $_SERVER['SERVER_PORT']; $bVerify = isset($aParams["verify"]) ? !!$aParams["verify"] : true; $iWarn = isset($aParams["warning"]) ? (int) ($aParams["warning"]) : 21; $iCrtitcal = isset($aParams["critical"]) ? (int) ($aParams["critical"]) : 5; $sMessage = "Checked url: $sUrl ... "; $certinfo = $this->_certGetInfos($sUrl, $bVerify); if (isset($certinfo['_error'])) { return [ RESULT_ERROR, $certinfo['_error'] . $sMessage ]; } $sDNS = $certinfo['extensions']['subjectAltName'] ?? false; $sHost = parse_url($sUrl, PHP_URL_HOST); if (strstr($sDNS, "DNS:$sHost") === false) { return [ RESULT_ERROR, "Wrong certificate: $sHost is not listed as DNS alias in [$sDNS]. $sMessage" ]; } $iDaysleft = round(($certinfo['validTo_time_t'] - date('U')) / 60 / 60 / 24); $sMessage .= 'Issuer: ' . $certinfo['issuer']['O'] . '; valid from: ' . date("Y-m-d H:i", $certinfo['validFrom_time_t']) . ' to ' . date("Y-m-d H:i", $certinfo['validTo_time_t']) . ' ' . ($iDaysleft ? "($iDaysleft days left)" : "expired since " . (-$iDaysleft) . " days.") ; if ($iDaysleft <= 0) { return [ RESULT_ERROR, 'Expired! ' . $sMessage ]; } if ($iDaysleft <= $iWarn) { return [ RESULT_WARNING, ($iDaysleft <= $iCrtitcal ? 'Expires very soon! ' : 'Expires soon. ' ) . $sMessage ]; } return [ RESULT_OK, 'OK. ' . ($bVerify ? 'Certificate is valid. ' : '(Verification is disabled; Check for expiration only.) ') . $sMessage ]; } } 
 class checkDiskfree extends appmonitorcheck { public function getGroup(): string { return 'disk'; } public function run(array $aParams): array { $this->_checkArrayKeys($aParams, "directory,critical"); $sDirectory = $aParams["directory"]; if (!is_dir($sDirectory)) { return [ RESULT_ERROR, "directory [$sDirectory] does not exist. Maybe it is wrong or is not mounted." ]; } $iWarn = isset($aParams["warning"]) ? $this->_getSize($aParams["warning"]) : false; $iCritical = $this->_getSize($aParams["critical"]); $iSpaceLeft = disk_free_space($sDirectory); $sMessage = $this->_getHrSize($iSpaceLeft) . ' left in [' . $sDirectory . '].'; if ($iWarn) { if ($iWarn <= $iCritical) { header('HTTP/1.0 503 Service Unavailable'); die("ERROR in a Diskfree check - warning value must be larger than critical.<pre>" . print_r($aParams, true)); } if ($iWarn < $iSpaceLeft) { return [ RESULT_OK, "$sMessage Warning level is not reached yet (still " . $this->_getHrSize($iSpaceLeft - $iWarn) . " over warning limit)." ]; } if ($iWarn > $iSpaceLeft && $iCritical < $iSpaceLeft) { return [ RESULT_WARNING, $sMessage . ' Warning level ' . $this->_getHrSize($iWarn) . ' was reached (space is ' . $this->_getHrSize($iWarn - $iSpaceLeft) . ' below warning limit; still ' . $this->_getHrSize($iSpaceLeft - $iCritical) . ' over critical limit).' ]; } } if ($iCritical < $iSpaceLeft) { return [RESULT_OK, $sMessage . ' Minimum is not reached yet (still ' . $this->_getHrSize($iSpaceLeft - $iCritical) . ' over critical limit).']; } else { return [RESULT_ERROR, $sMessage]; } } } 
 class checkExec extends appmonitorcheck { public function getGroup() { return 'service'; } public function run(array $aParams): array { $this->_checkArrayKeys($aParams, "command"); $_sCmd = $aParams['command']; $_bShowOutput = isset($aParams['output']) ? !!$aParams['output'] : true; $_aRcOK = isset($aParams['exitOK']) ? $aParams['exitOK'] : []; $_aRcWarning = isset($aParams['exitWarn']) ? $aParams['exitWarn'] : []; $_aRcCritical = isset($aParams['exitCritical']) ? $aParams['exitCritical'] : []; $_sMode = 'default'; if (count($_aRcOK) + count($_aRcWarning) + count($_aRcCritical)) { $_sMode = 'exitcode'; } exec($_sCmd, $aOutput, $iRc); $_sOut = $_bShowOutput ? '<br>' . implode("<br>", $aOutput) : ''; switch ($_sMode) { case "default": if ($iRc) { return [ RESULT_ERROR, 'command failed with exitcode ' . $iRc . ': [' . $_sCmd . ']' . $_sOut ]; } else { return [ RESULT_OK, "OK [$_sCmd] $_sOut" ]; } ; ; case "exitcode": if (in_array($iRc, $_aRcCritical)) { return [ RESULT_ERROR, "Critical exitcode $iRc detected: [$_sCmd] $_sOut" ]; } if (in_array($iRc, $_aRcWarning)) { return [ RESULT_WARNING, "Warning exitcode $iRc detected: [$_sCmd] $_sOut" ]; } if ($iRc == 0 || in_array($iRc, $_aRcOK)) { return [ RESULT_OK, "OK exitcode $iRc detected: [$_sCmd] $_sOut" ]; } return [ RESULT_UNKNOWN, "UNKNOWN - unhandled exitcode $iRc detected: [$_sCmd] $_sOut" ]; case "search": return [ RESULT_UNKNOWN, "UNKNOWN method [$_sMode] - is not implemented yet." ]; ; default: return [ RESULT_UNKNOWN, 'UNKNOWN mode [' . htmlentities($_sMode) . '].' ]; } } } 
 class checkFile extends appmonitorcheck { public function getGroup(array $aParams = []): string { $sReturn = 'file'; if (isset($aParams['dir'])) { $sReturn = 'folder'; } foreach (['exists', 'executable', 'readable', 'writable'] as $sFlag) { if (isset($aParams[$sFlag]) && !$aParams[$sFlag]) { $sReturn = 'deny'; } } return $sReturn; } public function run(array $aParams): array { $aOK = []; $aErrors = []; $this->_checkArrayKeys($aParams, "filename"); $sFile = $aParams["filename"]; if (isset($aParams['exists'])) { $sMyflag = 'exists=' . ($aParams['exists'] ? 'yes' : 'no'); if (file_exists($sFile) && $aParams['exists']) { $aOK[] = $sMyflag; } else { $aErrors[] = $sMyflag; } } foreach (['dir', 'executable', 'file', 'link', 'readable', 'writable'] as $sFiletest) { if (isset($aParams[$sFiletest])) { $sTestCmd = 'return is_' . $sFiletest . '("' . $sFile . '");'; if (eval ($sTestCmd) && $aParams[$sFiletest]) { $aOK[] = $sFiletest . '=' . ($aParams[$sFiletest] ? 'yes' : 'no'); } else { $aErrors[] = $sFiletest . '=' . ($aParams[$sFiletest] ? 'yes' : 'no'); } } } $sMessage = (count($aOK) ? ' flags OK: ' . implode('|', $aOK) : '') . ' ' . (count($aErrors) ? ' flags FAILED: ' . implode('|', $aErrors) : '') ; if (count($aErrors)) { return [ RESULT_ERROR, "file test [$sFile] $sMessage" ]; } else { return [ RESULT_OK, "file test [$sFile] $sMessage" ]; } } } 
 class checkHello extends appmonitorcheck { public function run(array $aParams): array { $this->_checkArrayKeys($aParams, "message"); return [ RESULT_OK, 'Hello world! My message is: ' . $aParams['message'] ]; } } 
 class checkHttpContent extends appmonitorcheck { public function getGroup(array $aParams=[]): string { $sReturn = 'service'; if (isset($aParams['status']) && $aParams['status'] > 300 && $aParams['status'] < 500) { $sReturn = 'deny'; } return $sReturn; } public function run(array $aParams) { $this->_checkArrayKeys($aParams, "url"); if (!function_exists("curl_init")) { return [RESULT_UNKNOWN, "UNKNOWN: Unable to perform mysqli test. The php-curl module is not active."]; } $bShowContent = (isset($aParams["content"]) && $aParams["content"]) ? true : false; $ch = curl_init($aParams["url"]); curl_setopt($ch, CURLOPT_HEADER, 1); curl_setopt($ch, CURLOPT_NOBODY, isset($aParams["headeronly"]) && $aParams["headeronly"]); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, isset($aParams["follow"]) && $aParams["follow"]); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, isset($aParams["sslverify"]) ? !!$aParams["sslverify"] : 1); curl_setopt($ch, CURLOPT_TIMEOUT, (isset($aParams["timeout"]) && (int) $aParams["timeout"]) ? (int) $aParams["timeout"] : $this->_iTimeoutTcp); if (isset($aParams["userpwd"])) { curl_setopt($ch, CURLOPT_USERPWD, $aParams["userpwd"]); } $res = curl_exec($ch); if (!$res) { $iErrorCode = curl_errno($ch); $sErrorMsg = curl_error($ch); curl_close($ch); return [ RESULT_ERROR, 'ERROR: failed to fetch ' . $aParams["url"] . ' - curl error #' . $iErrorCode . ': ' . $sErrorMsg ]; } $sOut = ''; $bError = false; $aInfos = curl_getinfo($ch); curl_close($ch); $aTmp = explode("\r\n\r\n", $res, 2); $sHttpHeader = $aTmp[0]; $sHttpBody = $aTmp[1] ?? false; $sOut .= "Http status: " . $aInfos['http_code'] . " - "; if (isset($aParams["status"])) { if ($aInfos['http_code'] === $aParams["status"]) { $sOut .= "compare OK<br>"; } else { $sOut .= "compare failed<br>"; $bError = true; } } else { if ($aInfos['http_code'] >= 400) { $sOut .= "Error page detected<br>"; $bError = true; } else { $sOut .= "request successful<br>"; } } if (isset($aParams["headercontains"]) && $aParams["headercontains"]) { $sOut .= "Http header contains &quot;" . $aParams["headercontains"] . "&quot; - "; if (!strstr($sHttpHeader, $aParams["headercontains"]) === false) { $sOut .= "compare OK<br>"; } else { $sOut .= "compare failed<br>"; $bError = true; } } if (isset($aParams["headernotcontains"]) && $aParams["headernotcontains"]) { $sOut .= "Http header does not contain &quot;" . $aParams["headernotcontains"] . "&quot; - "; if (strstr($sHttpHeader, $aParams["headernotcontains"]) === false) { $sOut .= "compare OK<br>"; } else { $sOut .= "compare failed<br>"; $bError = true; } } if (isset($aParams["headerregex"]) && $aParams["headerregex"]) { $sOut .= "Http header regex test &quot;" . $aParams["headerregex"] . "&quot; - "; try { $bRegex = preg_match($aParams["headerregex"], $sHttpHeader); if ($bRegex) { $sOut .= "compare OK<br>"; } else { $sOut .= "compare failed<br>"; $bError = true; } } catch (Exception $e) { $sOut .= "Wrong REGEX<br>" . print_r($e, 1) . '<br>'; $bError = true; } } if (isset($aParams["bodycontains"]) && $aParams["bodycontains"]) { $sOut .= "Http body contains &quot;" . $aParams["bodycontains"] . "&quot; - "; if (!strstr($sHttpBody, $aParams["bodycontains"]) === false) { $sOut .= "compare OK<br>"; } else { $sOut .= "compare failed<br>"; $bError = true; } } if (isset($aParams["bodynotcontains"]) && $aParams["bodynotcontains"]) { $sOut .= "Http body does not contain &quot;" . $aParams["bodynotcontains"] . "&quot; - "; if (strstr($sHttpBody, $aParams["bodynotcontains"]) === false) { $sOut .= "compare OK<br>"; } else { $sOut .= "compare failed<br>"; $bError = true; } } if (isset($aParams["bodyregex"]) && $aParams["bodyregex"]) { $sOut .= "Http body regex test &quot;" . $aParams["bodyregex"] . "&quot; - "; try { $bRegex = preg_match($aParams["bodyregex"], $sHttpBody); if ($bRegex) { $sOut .= "compare OK<br>"; } else { $sOut .= "compare failed<br>"; $bError = true; } } catch (Exception $e) { $sOut .= "Wrong REGEX<br>" . print_r($e, 1) . '<br>'; $bError = true; } } if (!$bError) { return [ RESULT_OK, 'OK: http check "' . $aParams["url"] . '".<br>' . $sOut ]; } else { return [ RESULT_ERROR, 'ERROR: http check "' . $aParams["url"] . '".<br>' . $sOut ]; } } } 
 class checkLoadmeter extends appmonitorcheck { public function getGroup(): string { return 'monitor'; } protected function _getLoad(): float { if (function_exists('sys_getloadavg')) { $load = sys_getloadavg(); return $load[0]; } else { if (class_exists('COM')) { $wmi = new COM('WinMgmts:\\\\.'); $cpus = $wmi->InstancesOf('Win32_Processor'); $load = 0; if (version_compare('4.50.0', PHP_VERSION) == 1) { while ($cpu = $cpus->Next()) { $load += $cpu->LoadPercentage; } } else { foreach ($cpus as $cpu) { $load += $cpu->LoadPercentage; } } return $load; } return false; } } public function run(array $aParams): array { $fLoad = $this->_getLoad(); if ($fLoad === false) { $iResult = RESULT_UNKNOWN; } else { $iResult = RESULT_OK; if (isset($aParams['warning']) && $aParams['warning'] && $fLoad > $aParams['warning']) { $iResult = RESULT_WARNING; } if (isset($aParams['error']) && $aParams['error'] && $fLoad > $aParams['error']) { $iResult = RESULT_ERROR; } } return [ $iResult, ($fLoad === false ? 'load value is not available' : 'current load is: ' . round($fLoad, 2)), ($fLoad === false ? [] : [ 'type' => 'counter', 'count' => round($fLoad, 2), 'visual' => 'line', ] ) ] ; } } 
 class checkMysqlConnect extends appmonitorcheck { public function getGroup(): string { return 'database'; } public function run(array $aParams): array { $this->_checkArrayKeys($aParams, "server,user,password,db"); if (!function_exists("mysqli_init")) { return [RESULT_UNKNOWN, "UNKNOWN: Unable to perform mysqli test. The php-mysqli module is not active."]; } $mysqli = mysqli_init(); if (!$mysqli) { return [RESULT_ERROR, 'ERROR: mysqli_init failed.']; } if (!$mysqli->options(MYSQLI_OPT_CONNECT_TIMEOUT, (isset($aParams["timeout"]) && (int) $aParams["timeout"]) ? (int) $aParams["timeout"] : $this->_iTimeoutTcp)) { return [RESULT_ERROR, 'ERROR: setting mysqli_options failed.']; } $db = (isset($aParams["port"]) && $aParams["port"]) ? $mysqli->real_connect($aParams["server"], $aParams["user"], $aParams["password"], $aParams["db"], $aParams["port"]) : $mysqli->real_connect($aParams["server"], $aParams["user"], $aParams["password"], $aParams["db"]) ; if ($db) { $mysqli->close(); return [RESULT_OK, "OK: Mysql database " . $aParams["db"] . " was connected"]; } else { return [ RESULT_ERROR, "ERROR: Mysql database " . $aParams["db"] . " was not connected. Error " . mysqli_connect_errno() . ": " . mysqli_connect_error() ]; } } } 
 class checkPdoConnect extends appmonitorcheck { public function getGroup(): string { return 'database'; } public function run(array $aParams): array { $this->_checkArrayKeys($aParams, "connect,user,password"); try { $db = new PDO( $aParams['connect'], $aParams['user'], $aParams['password'], [ PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_TIMEOUT => (isset($aParams["timeout"]) && (int) $aParams["timeout"]) ? (int) $aParams["timeout"] : $this->_iTimeoutTcp, ] ); $db = null; return [RESULT_OK, "OK: Database was connected with PDO " . $aParams['connect']]; } catch (PDOException $e) { return [RESULT_ERROR, "ERROR: Database was not connected " . $aParams['connect'] . " was not connected. Error " . $e->getMessage()]; } } } 
 class checkPhpmodules extends appmonitorcheck { public function getGroup(): string { return 'service'; } public function run(array $aParams): array { $sOut = ''; $bHasError = false; $bHasWarning = false; $aAllMods = get_loaded_extensions(false); if (isset($aParams['required']) && count($aParams['required'])) { $sOut .= 'Required: '; foreach ($aParams['required'] as $sMod) { $sOut .= $sMod . '='; if (!array_search($sMod, $aAllMods) === false) { $sOut .= 'OK;'; } else { $bHasError = true; $sOut .= 'MISS;'; } } } if (isset($aParams['optional']) && count($aParams['optional'])) { $sOut .= ($sOut ? '|' : '') . 'Optional: '; foreach ($aParams['optional'] as $sMod) { $sOut .= $sMod . '='; if (!array_search($sMod, $aAllMods) === false) { $sOut .= 'OK;'; } else { $bHasWarning = true; $sOut .= 'MISS;'; } } } if ($bHasError) { return [RESULT_ERROR, "ERROR: " . $sOut]; } if ($bHasWarning) { return [RESULT_WARNING, "WARNING: " . $sOut]; } return [RESULT_OK, "OK: " . $sOut]; } } 
 class checkPing extends appmonitorcheck { public function getGroup(): string { return 'network'; } public function run(array $aParams): array { $sHost = $aParams['host'] ?? '127.0.0.1'; $sParamCount = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' ? "n" : "c"; $iRepeat = 1; $sCommand = "ping -$sParamCount $iRepeat $sHost 2>&1"; exec($sCommand, $aOut, $iRc); $sOut = implode("\n", $aOut); if ($iRc > 0) { return [RESULT_ERROR, "ERROR: ping to $sHost failed.\n" . $sOut]; } return [RESULT_OK, "OK: ping to $sHost\n" . $sOut]; } } 
 class checkPortTcp extends appmonitorcheck { public function getGroup(): string { return 'network'; } public function run(array $aParams): array { $this->_checkArrayKeys($aParams, "port"); $sHost = $aParams['host'] ?? '127.0.0.1'; $iPort = (int) $aParams['port']; if (!function_exists('socket_create')) { return [RESULT_UNKNOWN, "UNKNOWN: Unable to perform tcp test. The php-sockets module is not enabled in the php installation."]; } $socket = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP); if ($socket === false) { return [RESULT_UNKNOWN, "ERROR: $sHost:$iPort was not checked. socket_create() failed: " . socket_strerror(socket_last_error())]; } socket_set_option( $socket, SOL_SOCKET, SO_SNDTIMEO, [ "sec" => (isset($aParams["timeout"]) && (int) $aParams["timeout"]) ? (int) $aParams["timeout"] : $this->_iTimeoutTcp, "usec" => 0 ] ); $result = @socket_connect($socket, $sHost, $iPort); if ($result === false) { $aResult = [RESULT_ERROR, "ERROR: $sHost:$iPort failed. " . socket_strerror(socket_last_error($socket))]; socket_close($socket); return $aResult; } else { socket_close($socket); return [RESULT_OK, "OK: $sHost:$iPort was connected."]; } } } 
 class checkSimple extends appmonitorcheck { public function run(array $aParams): array { $this->_checkArrayKeys($aParams, "result,value"); $aData = []; foreach (['type', 'count', 'visual'] as $sMyKey) { if (isset($aParams[$sMyKey])) { $aData[$sMyKey] = $aParams[$sMyKey]; } } return [ $aParams["result"], $aParams["value"], count($aData) ? $aData : false ]; } } 
 class checkSqliteConnect extends appmonitorcheck { public function getGroup() { return 'database'; } public function run($aParams): array { $this->_checkArrayKeys($aParams, "db"); if (!file_exists($aParams["db"])) { return [ RESULT_ERROR, "ERROR: Sqlite database file " . $aParams["db"] . " does not exist." ]; } if (!isset($aParams['user'])) { $aParams['user'] = ''; } if (!isset($aParams['password'])) { $aParams['password'] = ''; } try { $o = new PDO( "sqlite:" . $aParams["db"], $aParams['user'], $aParams['password'], [ PDO::ATTR_TIMEOUT => (isset($aParams["timeout"]) && (int) $aParams["timeout"]) ? (int) $aParams["timeout"] : $this->_iTimeoutTcp, ] ); return [ RESULT_OK, "OK: Sqlite database " . $aParams["db"] . " was connected" ]; } catch (Exception $e) { return [ RESULT_ERROR, "ERROR: Sqlite database " . $aParams["db"] . " was not connected. " . $e->getMessage() ]; } } } 
 if (!defined('RESULT_OK')) { define("RESULT_OK", 0); define("RESULT_UNKNOWN", 1); define("RESULT_WARNING", 2); define("RESULT_ERROR", 3); } class appmonitorcheck { protected float $_iStart = 0; protected array $_aConfig = []; protected array $_aData = []; protected array $_units = ['B', 'KB', 'MB', 'GB', 'TB']; protected int $_iTimeoutTcp = 5; protected string $_sPluginDir = __DIR__ . '/../plugins'; public function __construct() { } protected function _createDefaultMetadata(): bool { $this->_aData = [ "name" => $this->_aConfig["name"], "description" => $this->_aConfig["description"], "group" => isset($this->_aConfig["group"]) ? $this->_aConfig["group"] : false, "parent" => isset($this->_aConfig["parent"]) ? $this->_aConfig["parent"] : false, "result" => RESULT_UNKNOWN, "value" => false, "type" => false, "time" => false, ]; return true; } protected function _setResult(int $iResult): bool { $this->_aData["result"] = (int) $iResult; return true; } protected function _setOutput(string $s): bool { $this->_aData["value"] = $s; return true; } protected function _setCounter(array $aParams): bool { if (is_array($aParams) && count($aParams)) { foreach (['type', 'count', 'visual'] as $sMyKey) { if (isset($aParams[$sMyKey])) { $this->_aData[$sMyKey] = $aParams[$sMyKey]; } } } return true; } protected function _setReturn(int $iResult, string $s, array $aCounter = []) { $this->_setResult($iResult); $this->_setOutput($s); $this->_setCounter($aCounter); return true; } protected function _checkArrayKeys($aConfig, $sKeyList) { foreach (explode(",", $sKeyList) as $sKey) { if (!isset($aConfig[$sKey])) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - array of check parameters requires the keys [$sKeyList] - but key <code>$sKey</code> was not found in config array." . "<pre>" . print_r($aConfig, true) . '</pre>' ); } if (is_null($aConfig[$sKey])) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - key <code>$sKey</code> is empty in config array" . "<pre>" . print_r($aConfig, true) . '</pre>' ); } } return true; } public function makeCheck(array $aConfig): array { $this->_iStart = microtime(true); $this->_checkArrayKeys($aConfig, "name,description,check"); $this->_checkArrayKeys($aConfig["check"], "function"); $this->_aConfig = $aConfig; $this->_createDefaultMetadata(); $sCheck = preg_replace('/[^a-zA-Z0-9]/', '', $this->_aConfig["check"]["function"]); $aParams = $this->_aConfig["check"]["params"] ?? []; $sPluginFile = strtolower($this->_sPluginDir . '/checks/' . $sCheck . '.php'); $sCheckClass = 'check' . $sCheck; if (!class_exists($sCheckClass)) { if (file_exists($sPluginFile)) { } } if (!class_exists($sCheckClass)) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - check class not found: <code>$sCheckClass</code>" . "<pre>" . print_r($aConfig, true) . '</pre>' . "<h2>Known checks</h2>\n" . print_r($this->listChecks(), 1) ); } $oPlugin = new $sCheckClass; $aResponse = $oPlugin->run($aParams); if (!is_array($aResponse)) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - plugin : $sCheck does not responses an array" . "<pre>INPUT " . print_r($aConfig, true) . '</pre>' . "<pre>RESPONSE " . print_r($aResponse, true) . '</pre>' ); } if (count($aResponse) < 2) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - plugin : $sCheck does not responses the minimum of 2 array values" . "<pre>INPUT " . print_r($aConfig, true) . '</pre>' . "<pre>RESPONSE " . print_r($aResponse, true) . '</pre>' ); } if (!isset($aResponse[2]) || !$aResponse[2]) { $aResponse[2] = []; } $this->_setReturn($aResponse[0], $aResponse[1], $aResponse[2]); if (!$this->_aData['group'] && method_exists($oPlugin, "getGroup")) { $this->_aData['group'] = $oPlugin->getGroup($aParams); } $this->_aData['time'] = number_format((microtime(true) - $this->_iStart) * 1000, 3) . 'ms'; return $this->respond(); } public function listChecks(): array { $aReturn = []; $class = new ReflectionClass($this); foreach ($class->getMethods(ReflectionMethod::IS_PROTECTED) as $oReflectionMethod) { if (strpos($oReflectionMethod->name, "check") === 0) { $aReturn[(string) $oReflectionMethod->name] = 1; } } foreach (glob($this->_sPluginDir . '/checks/*.php') as $sPluginFile) { $aReturn[str_replace('.php', '', basename($sPluginFile))] = 1; } foreach(get_declared_classes() as $sClass){ if (strpos($sClass, "check") === 0) { $aReturn[str_replace('check','',$sClass)] = 1; } } array_unique($aReturn); ksort($aReturn); return array_keys($aReturn); } public function respond() { return $this->_aData; } protected function _certGetInfos(string $sUrl, bool $bVerifyCert): array { $iTimeout = 10; $aUrldata = parse_url($sUrl); $sHost = isset($aUrldata['host']) ? $aUrldata['host'] : false; $iPort = isset($aUrldata['port']) ? $aUrldata['port'] : ((isset($aUrldata['scheme']) && $aUrldata['scheme'] === 'https') ? 443 : false); $aSsl = ['capture_peer_cert' => true]; if ($bVerifyCert) { $aSsl['verify_peer'] = false; $aSsl['verify_peer_name'] = false; } ; $get = stream_context_create(['ssl' => $aSsl]); if (!$get) { return ['_error' => 'Error: Cannot create stream_context']; } $errno = -1; $errstr = "stream_socket_client failed."; $read = stream_socket_client("ssl://$sHost:$iPort", $errno, $errstr, $iTimeout, STREAM_CLIENT_CONNECT, $get); if (!$read) { return ['_error' => "Error $errno: $errstr; cannot create stream_socket_client with given stream_context to ssl://$sHost:$iPort; you can try to set the flag [verify] to false to check expiration date only."]; } $cert = stream_context_get_params($read); if (!$cert) { return ['_error' => "Error: socket was connected to ssl://$sHost:$iPort - but I cannot read certificate infos with stream_context_get_params "]; } return openssl_x509_parse($cert['options']['ssl']['peer_certificate']); } protected function _getHrSize(int $size): string { $power = $size > 0 ? floor(log($size, 1024)) : 0; return number_format($size / pow(1024, $power), 2, '.', ',') . ' ' . $this->_units[$power]; } protected function _getSize(string $sValue): int { if (is_int($sValue)) { return $sValue; } $power = 0; foreach ($this->_units as $sUnit) { if (preg_match('/^[0-9\.\ ]*' . $sUnit . '/', $sValue)) { $i = preg_replace('/([0-9\.]*).*/', '$1', $sValue); $iReal = $i * pow(1024, $power); return $iReal; } $power++; } header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " ERROR in space value parameter - there is no size unit in [$sValue] - allowed size units are " . implode('|', $this->_units) ); } } 
if (!class_exists('appmonitorcheck')) { } class appmonitor { protected string $_sVersion = 'php-client-v0.152'; protected int $_iDefaultTtl = 300; protected int $_iMaxResult = -1; protected array $_aMeta = []; protected array $_aChecks = []; protected float $_iStart = 0; public function __construct() { $this->_createDefaultMetadata(); } protected function _createDefaultMetadata(): bool { $this->_iStart = microtime(true); $this->_aMeta = [ "host" => false, "website" => false, "ttl" => false, "result" => false, "time" => false, "version" => $this->_sVersion, ]; $this->setHost(); $this->setWebsite(); $this->setTTL(); return true; } public function setHost(string $s = ''): bool { if (!$s) { $s = php_uname("n"); } if (!$s) { return false; } $this->_aMeta["host"] = $s; return true; } public function setWebsite($sWebsite = ''): bool { if (!$sWebsite && isset($_SERVER["HTTP_HOST"])) { $sWebsite = $_SERVER["HTTP_HOST"]; } if (!$sWebsite) { return false; } $this->_aMeta["website"] = $sWebsite; return true; } public function setTTL($iTTl = 0) { if ($iTTl == 0) { $iTTl = $this->_iDefaultTtl; } return $this->_aMeta["ttl"] = $iTTl; } public function setResult(int $iResult = -1): bool { if ($iResult === -1) { $iResult = $this->_iMaxResult; } $this->_aMeta["result"] = $iResult; return true; } public function addCheck($aJob = []): bool { $oCheck = new appmonitorcheck(); $aCheck = $oCheck->makecheck($aJob); $iMyResult = isset($aJob['worstresult']) ? min($aCheck["result"], $aJob['worstresult']) : $aCheck["result"] ; if (!$this->_iMaxResult || $iMyResult > $this->_iMaxResult) { $this->_iMaxResult = $iMyResult; } $this->_aChecks[] = $aCheck; return true; } protected function _addNotification(string $sType, string $sValue, string $sKey = ''): bool { $sTypeCleaned = preg_replace('/[^a-z]/', '', strtolower($sType)); if (!isset($this->_aMeta['notifications'])) { $this->_aMeta['notifications'] = []; } if (!isset($this->_aMeta['notifications'][$sTypeCleaned])) { $this->_aMeta['notifications'][$sTypeCleaned] = []; } if ($sKey) { $this->_aMeta['notifications'][$sTypeCleaned][$sKey] = $sValue; } else { $this->_aMeta['notifications'][$sTypeCleaned][] = $sValue; } return true; } public function addEmail(string $sEmailAddress) { return $this->_addNotification('email', $sEmailAddress); } public function addSlackWebhook(string $sLabel, string $sSlackWebhookUrl): bool { return $this->_addNotification('slack', $sSlackWebhookUrl, $sLabel); } public function addTag(string $sTag): bool { if (!isset($this->_aMeta['tags'])) { $this->_aMeta['tags'] = []; } $this->_aMeta['tags'][] = str_replace(' ', '_', $sTag); return true; } public function checkIp(array $aAllowedIps = []): bool { if (!isset($_SERVER['REMOTE_ADDR']) || !count($aAllowedIps)) { return true; } $sIP = $_SERVER['REMOTE_ADDR']; foreach ($aAllowedIps as $sIp2Check) { if (strpos($sIP, $sIp2Check) === 0) { return true; } } header('HTTP/1.0 403 Forbidden'); die('ERROR: Your ip address [' . $sIP . '] has no access.'); } public function checkToken(string $sVarname, string $sToken): bool { if (!isset($_GET)) { return true; } if (isset($_GET[$sVarname]) && $_GET[$sVarname] === $sToken) { return true; } header('HTTP/1.0 403 Forbidden'); die('ERROR: A token is required.'); } public function listChecks(): array { $oCheck = new appmonitorcheck(); return $oCheck->listChecks(); } protected function _checkData(): bool { $aErrors = []; if (!count($this->_aChecks)) { $aErrors[] = "No checks have been defined."; } if ($this->_aMeta["result"] === false) { $aErrors[] = "method setResult was not used to set a final result for all checks."; } if (count($aErrors)) { $this->abort( '<h2>Error: client check is not complete</h2><p>Found errors:</p><ol><li>' . implode('<li>', $aErrors) . '</ol><br><br>' ); } return true; } public function abort(string $sMessage): void { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . $sMessage); } public function getChecks(): array { return $this->_aChecks; } public function getResults(): array { return [ "meta" => $this->_aMeta, "checks" => $this->_aChecks, ]; } public function render(): string { $this->_checkData(); $this->_aMeta['time'] = number_format((microtime(true) - $this->_iStart) * 1000, 3) . 'ms'; $sOut=json_encode($this->getResults()); header('Content-type: application/json'); header('Cache-Control: cache'); header('max-age: ' . $this->_aMeta["ttl"]); echo $sOut; return $sOut; } public function renderHtmloutput(string $sJson): string { header('Content-type: text/html'); header('Cache-Control: cache'); header('max-age: ' . $this->_aMeta["ttl"]); $aMsg = [ 0 => "OK", 1 => "UNKNOWN", 2 => "WARNING", 3 => "ERROR" ]; $aData = json_decode($sJson, 1); $sOut = ''; $sOut .= '' . '<h2>Metadata</h2>' . '<div class="meta' . (isset($aData['meta']['result']) ? ' result' . $aData['meta']['result'] : '') . '">' . 'Status: ' . (isset($aData['meta']['result']) ? $aMsg[$aData['meta']['result']] : '?') . '<br>' . '</div>' . 'Host: ' . (isset($aData['meta']['host']) ? '<span class="string">' . $aData['meta']['host'] . '</span>' : '?') . '<br>' . 'Website: ' . (isset($aData['meta']['website']) ? '<span class="string">' . $aData['meta']['website'] . '</span>' : '?') . '<br>' . 'Execution time: ' . (isset($aData['meta']['time']) ? '<span class="float">' . $aData['meta']['time'] . '</span>' : '?') . '<br>' . 'Client: ' . (isset($aData['meta']['version']) ? '<span class="string">' . $aData['meta']['version'] . '</span>' : '?') . '<br>' . '<h2>Checks</h2>' ; if (isset($aData['checks'][0]) && count($aData['checks'])) { foreach ($aData['checks'] as $aCheck) { $sOut .= '' . '<span class="result' . $aCheck['result'] . '"> <strong>' . $aCheck['name'] . '</strong></span> <br>' . '<div class="check">' . '<div class="description">' . $aCheck['description'] . '<br>' . $aCheck['value'] . '<br>' . '</div>' . 'Execution time: <span class="float">' . (isset($aCheck['time']) ? $aCheck['time'] : ' - ') . '</span><br>' . 'Group: <span class="string">' . (isset($aCheck['group']) ? $aCheck['group'] : '-') . '</span><br>' . 'parent: <span class="string">' . (isset($aCheck['parent']) ? $aCheck['parent'] : '-') . '</span><br>' . 'Status: ' . $aMsg[$aCheck['result']] . '<br>' . '</div>' ; } } $sOut .= '<h2>List of farbcodes</h2>'; foreach ($aMsg as $i => $sText) { $sOut .= '<span class="result' . $i . '">' . $sText . '</span> '; } $sRaw=json_encode($aData, JSON_PRETTY_PRINT); $sRaw = preg_replace('/:\ \"(.*)\"/U', ': "<span class="string">$1</span>"', $sRaw); $sRaw = preg_replace('/:\ ([0-9]*)/', ': <span class="int">$1</span>', $sRaw); $sRaw = preg_replace('/\"(.*)\":/U', '"<span class="key">$1</span>":', $sRaw); $sOut .= '<h2>Raw result data</h2><pre id="raw">' . $sRaw . '</pre>'; $sOut = '<!DOCTYPE html><html><head>' . '<style>' . 'body{background:#eee; color:#444; font-family: verdana,arial; margin: 0; }' . 'body>div#content{background: #fff; border-radius: 2em; border: 4px solid #abc; box-shadow: 0.5em 0.5em 2em #aaa; margin: 2em 10%; padding: 2em;}' . 'h1{color:#346; margin: 0;}' . 'h2{color:#569; margin-top: 2em;}' . 'pre{background:#f4f4f8; padding: 1em; overflow-x:auto; }' . '#raw .key{color:#808;}' . '#raw .int{color:#3a3; font-weight: bold;}' . '#raw .string{color:#66e;}' . '.check{border: 1px solid #ccc; padding: 0.4em; margin-bottom: 2em;}' . '.description{font-style: italic; padding: 0.4em 1em;}' . '.float{color:#080;}' . '.meta{margin-bottom: 1em;}' . '.result0{background:#aca; border-left: 1em solid #080; padding: 0.5em; }' . '.result1{background:#ccc; border-left: 1em solid #aaa; padding: 0.5em; }' . '.result2{background:#fc9; border-left: 1em solid #860; padding: 0.5em; }' . '.result3{background:#f88; border-left: 1em solid #f00; padding: 0.5em; }' . '.string{color:#338;}' . '</style>' . '<title>' . __CLASS__ . '</title>' . '</head><body>' . '<div id="content">' . '<h1>' . __CLASS__ . ' :: client status</h1>' . $sOut . '</div>' . '</body></html>'; return $sOut; } } 