<?php
/*

    MERGED APPMONITOR CLIENT :: WORK IN PROGRESS

    generated Mon Jul 22 14:37:44 CEST 2024

*/

 class checkApacheProcesses extends appmonitorcheck{ protected $_sServerStatusUrl = 'http://localhost/server-status'; protected $_iWarn = 50; protected $_iError = 75; protected function _getApacheProcesses() { $sBody = file_get_contents($this->_sServerStatusUrl); if(!$sBody){ return false; } $sRegexScoreboard = '/<pre>(.*)\<\/pre\>/U'; $aScore=[]; $sStatusNobr = str_replace("\n", "", $sBody); if (preg_match_all($sRegexScoreboard, $sStatusNobr, $aTmpTable)) { $sScoreString=$aTmpTable[1][0]; $aScore['total']=strlen($sScoreString); $aScore['free']=substr_count($sScoreString, '.'); $aScore['waiting']=substr_count($sScoreString, '_'); $aScore['active']=$aScore['total']-$aScore['free']-$aScore['waiting']; } return $aScore; } public function getGroup(){ return 'monitor'; } public function run($aParams){ if(isset($aParams['url']) && $aParams['url']){ $this->_sServerStatusUrl=$aParams['url']; } if(isset($aParams['warning']) && (int)$aParams['warning']){ $this->_iWarn=(int)$aParams['warning']; } if(isset($aParams['error']) && (int)$aParams['error']){ $this->_iError=(int)$aParams['error']; } $aProcesses=$this->_getApacheProcesses(); $iActive=$aProcesses ? $aProcesses['active'] : false; if($iActive===false){ $iResult=RESULT_UNKNOWN; } else { $sComment=''; $iTotal=$aProcesses['total']; $iResult=RESULT_OK; if(($iActive/$iTotal*100)>$this->_iWarn){ $iResult=RESULT_WARNING; $sComment='more than warning level '.$this->_iWarn.'%'; } else { $sComment='less than warning level '.$this->_iWarn.'%'; } if(($iActive/$iTotal*100)>$this->_iError){ $iResult=RESULT_ERROR; $sComment='more than error level '.$this->_iError.'%'; } } return [ $iResult, ($iActive===false ? 'Apache httpd server status is not available' : 'apache processes: '.print_r($aProcesses, 1)).' '.$sComment, ($iActive===false ? [] : [ 'type'=>'counter', 'count'=>$iActive, 'visual'=>'line', ] ) ]; } } 
 class checkCert extends appmonitorcheck{ public function getGroup(){ return 'security'; } public function run($aParams) { $sUrl = isset($aParams["url"]) ? $aParams["url"] : 'http'. ($_SERVER['HTTPS'] ? 's' : '') . '://' . $_SERVER['SERVER_NAME'] .':' . $_SERVER['SERVER_PORT'] ; $bVerify = isset($aParams["verify"]) ? !!$aParams["verify"] : true; $iWarn = isset($aParams["warning"]) ? (int)($aParams["warning"]) : 21; $iCrtitcal = isset($aParams["critical"]) ? (int)($aParams["critical"]) : 5; $sMessage="Checked url: $sUrl ... "; $certinfo=$this->_certGetInfos($sUrl, $bVerify); if(isset($certinfo['_error'])){ return [ RESULT_ERROR, $certinfo['_error'] . $sMessage ]; } $sDNS=isset($certinfo['extensions']['subjectAltName']) ? $certinfo['extensions']['subjectAltName'] : false; $sHost=parse_url($sUrl,PHP_URL_HOST); if(strstr($sDNS, 'DNS:'.$sHost)===false){ return [ RESULT_ERROR, 'Wrong certificate: '.$sHost.' is not listed as DNS alias in ['.$sDNS.']  ' . $sMessage ]; } $iDaysleft = round(($certinfo['validTo_time_t'] - date('U')) / 60 / 60 / 24); $sMessage.= 'Issuer: '. $sIssuer=$certinfo['issuer']['O'] . '; valid from: '. date("Y-m-d H:i", $certinfo['validFrom_time_t']) . ' to '.date("Y-m-d H:i", $certinfo['validTo_time_t']).' ' . ( $iDaysleft ? "($iDaysleft days left)" : "expired since ".(-$iDaysleft)." days.") ; if ($iDaysleft<=0) { return [ RESULT_ERROR, 'Expired! ' . $sMessage ]; } if ($iDaysleft<=$iWarn) { return [ RESULT_WARNING, ($iDaysleft<=$iCrtitcal ? 'Expires very soon! ' : 'Expires soon. ' ). $sMessage ]; } return [ RESULT_OK, 'OK. ' .($bVerify ? 'Certificate is valid. ' : '(Verification is disabled; Check for expiration only.) ' ) . $sMessage ]; } } 
 class checkDiskfree extends appmonitorcheck{ public function getGroup(){ return 'disk'; } public function run($aParams) { $this->_checkArrayKeys($aParams, "directory", "critical"); $sDirectory = $aParams["directory"]; if(!is_dir($sDirectory)){ return [ RESULT_ERROR, 'directory [' . $sDirectory . '] does not exist. Maybe it is wrong or is not mounted.' ]; } $iWarn = isset($aParams["warning"]) ? $this->_getSize($aParams["warning"]) : false; $iCritical = $this->_getSize($aParams["critical"]); $iSpaceLeft=disk_free_space($sDirectory); $sMessage='[' . $sDirectory . '] has '.$this->_getHrSize($iSpaceLeft).' left.'; if($iWarn){ if($iWarn<=$iCritical){ header('HTTP/1.0 503 Service Unavailable'); die("ERROR in a Diskfree check - warning value must be larger than critical.<pre>" . print_r($aParams, true)); } if ($iWarn<$iSpaceLeft){ return [ RESULT_OK, $sMessage.' Warning level is not reached yet (still '.$this->_getHrSize($iSpaceLeft-$iWarn).' over warning limit).' ]; } if ($iWarn>$iSpaceLeft && $iCritical<$iSpaceLeft){ return [ RESULT_WARNING, $sMessage.' Warning level '.$this->_getHrSize($iWarn).' was reached (space is '.$this->_getHrSize($iWarn-$iSpaceLeft).' below warning limit; still '.$this->_getHrSize($iSpaceLeft-$iCritical).' over critical limit).' ]; } } if ($iCritical<$iSpaceLeft){ return [RESULT_OK, $sMessage .' Minimum is not reached yet (still '.$this->_getHrSize($iSpaceLeft-$iCritical).' over critical limit).']; } else { return [RESULT_ERROR, $sMessage]; } } } 
 class checkExec extends appmonitorcheck{ public function getGroup($aParams){ return 'service'; } public function run($aParams) { $this->_checkArrayKeys($aParams, "command"); $_sCmd=$aParams['command']; $_bShowOutput=isset($aParams['output']) ? !!$aParams['output'] : true; $_aRcOK=isset($aParams['exitOK']) ? $aParams['exitOK'] : []; $_aRcWarning=isset($aParams['exitWarn']) ? $aParams['exitWarn'] : []; $_aRcCritical=isset($aParams['exitCritical']) ? $aParams['exitCritical'] : []; $_sMode='default'; if(count($_aRcOK) + count($_aRcWarning) + count($_aRcCritical)){ $_sMode='exitcode'; } exec($_sCmd,$aOutput, $iRc); $_sOut=$_bShowOutput ? '<br>'.implode("<br>", $aOutput) : ''; switch($_sMode){ case "default": if ($iRc) { return [ RESULT_ERROR, 'command failed with exitcode '.$iRc.': [' . $_sCmd . ']'.$_sOut ]; } else { return[ RESULT_OK, 'OK [' . $_sCmd . '] ' .$_sOut ]; }; break;; case "exitcode": if (in_array($iRc, $_aRcCritical)){ return [ RESULT_ERROR, 'Critical exitcode '.$iRc.' detected: [' . $_sCmd . ']'.$_sOut ]; } if (in_array($iRc, $_aRcWarning)){ return [ RESULT_WARNING, 'Warning exitcode '.$iRc.' detected: [' . $_sCmd . ']'.$_sOut ]; } if ($iRc == 0 || in_array($iRc, $_aRcOK)){ return [ RESULT_OK, 'OK exitcode '.$iRc.' detected: [' . $_sCmd . ']'.$_sOut ]; } return [ RESULT_UNKNOWN, 'UNKNOWN - unhandled exitcode '.$iRc.' detected: [' . $_sCmd . ']'.$_sOut ]; case "search": return[ RESULT_UNKNOWN, 'UNKNOWN method [' . $_sMode . '] - is not implemented yet.' ]; break;; default: return[ RESULT_UNKNOWN, 'UNKNOWN mode [' . htmlentities($_sMode) . '].' ]; } } } 
 class checkFile extends appmonitorcheck{ public function getGroup($aParams){ $sReturn='file'; if(isset($aParams['dir'])){ $sReturn='folder'; } foreach(['exists', 'executable', 'readable', 'writable'] as $sFlag){ if (isset($aParams[$sFlag]) && !$aParams[$sFlag]){ $sReturn='deny'; } } return $sReturn; } public function run($aParams) { $aOK = []; $aErrors = []; $this->_checkArrayKeys($aParams, "filename"); $sFile = $aParams["filename"]; if (isset($aParams['exists'])) { $sMyflag = 'exists=' . ($aParams['exists'] ? 'yes' : 'no'); if (file_exists($sFile) && $aParams['exists']) { $aOK[] = $sMyflag; } else { $aErrors[] = $sMyflag; } } foreach ([ 'dir', 'executable', 'file', 'link', 'readable', 'writable' ] as $sFiletest) { if (isset($aParams[$sFiletest])) { $sTestCmd = 'return is_' . $sFiletest . '("' . $sFile . '");'; if (eval($sTestCmd) && $aParams[$sFiletest]) { $aOK[] = $sFiletest . '=' . ($aParams[$sFiletest] ? 'yes' : 'no'); } else { $aErrors[] = $sFiletest . '=' . ($aParams[$sFiletest] ? 'yes' : 'no'); } } } $sMessage = (count($aOK) ? ' flags OK: ' . implode('|', $aOK) : '') . ' ' . (count($aErrors) ? ' flags FAILED: ' . implode('|', $aErrors) : '') ; if (count($aErrors)) { return [ RESULT_ERROR, 'file test [' . $sFile . '] ' . $sMessage ]; } else { return[ RESULT_OK, 'file test [' . $sFile . '] ' . $sMessage ]; } } } 
 class checkHello extends appmonitorcheck{ public function run($aParams){ $this->_checkArrayKeys($aParams, "message"); return [ RESULT_OK, 'Hello world! My message is: ' .$aParams['message'] ]; } } 
 class checkHttpContent extends appmonitorcheck{ public function getGroup($aParams){ $sReturn='service'; if(isset($aParams['status']) && $aParams['status'] > 300 && $aParams['status'] < 500 ){ $sReturn='deny'; } return $sReturn; } public function run($aParams) { $this->_checkArrayKeys($aParams, "url"); if (!function_exists("curl_init")) { header('HTTP/1.0 503 Service Unavailable'); die("ERROR: PHP CURL module is not installed."); } $bShowContent = (isset($aParams["content"]) && $aParams["content"]) ? true : false; $ch = curl_init($aParams["url"]); curl_setopt($ch, CURLOPT_HEADER, 1); curl_setopt($ch, CURLOPT_NOBODY, isset($aParams["headeronly"]) && $aParams["headeronly"]); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, isset($aParams["follow"]) && $aParams["follow"]); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, isset($aParams["sslverify"]) ? !!$aParams["sslverify"] : 1); curl_setopt($ch, CURLOPT_TIMEOUT, (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp); if (isset($aParams["userpwd"])){ curl_setopt($ch, CURLOPT_USERPWD, $aParams["userpwd"]); } $res = curl_exec($ch); if (!$res) { $iErrorCode=curl_errno($ch); $sErrorMsg=curl_error($ch); curl_close($ch); return [ RESULT_ERROR, 'ERROR: failed to fetch ' . $aParams["url"] . ' - curl error #'.$iErrorCode.': '.$sErrorMsg ]; } $sOut=''; $bError=false; $aInfos = curl_getinfo($ch); curl_close($ch); $aTmp=explode("\r\n\r\n", $res, 2); $sHttpHeader=$aTmp[0]; $sHttpBody=isset($aTmp[1]) ? $aTmp[1] : false; $sOut.="Http status: ".$aInfos['http_code']." - "; if(isset($aParams["status"])){ if($aInfos['http_code'] === $aParams["status"]){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } else { if($aInfos['http_code'] >= 400){ $sOut.="Error page detected<br>"; $bError=true; } else { $sOut.="request successful<br>"; } } if(isset($aParams["headercontains"]) && $aParams["headercontains"]){ $sOut.="Http header contains &quot;".$aParams["headercontains"]."&quot; - "; if(!strstr($sHttpHeader, $aParams["headercontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["headernotcontains"]) && $aParams["headernotcontains"]){ $sOut.="Http header does not contain &quot;".$aParams["headernotcontains"]."&quot; - "; if(strstr($sHttpHeader, $aParams["headernotcontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["headerregex"]) && $aParams["headerregex"]){ $sOut.="Http header regex test &quot;".$aParams["headerregex"]."&quot; - "; try{ $bRegex=preg_match($aParams["headerregex"], $sHttpHeader); if($bRegex){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } catch(Exception $e){ $sOut.="Wrong REGEX<br>" . print_r($e, 1).'<br>'; $bError=true; } } if(isset($aParams["bodycontains"]) && $aParams["bodycontains"]){ $sOut.="Http body contains &quot;".$aParams["bodycontains"]."&quot; - "; if(!strstr($sHttpBody, $aParams["bodycontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["bodynotcontains"]) && $aParams["bodynotcontains"]){ $sOut.="Http body does not contain &quot;".$aParams["bodynotcontains"]."&quot; - "; if(strstr($sHttpBody, $aParams["bodynotcontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["bodyregex"]) && $aParams["bodyregex"]){ $sOut.="Http body regex test &quot;".$aParams["bodyregex"]."&quot; - "; try{ $bRegex=preg_match($aParams["bodyregex"], $sHttpBody); if($bRegex){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } catch(Exception $e){ $sOut.="Wrong REGEX<br>" . print_r($e, 1).'<br>'; $bError=true; } } if (!$bError) { return [ RESULT_OK, 'OK: http check "' . $aParams["url"] . '".<br>'.$sOut ]; } else { return [ RESULT_ERROR, 'ERROR: http check "' . $aParams["url"] . '".<br>'.$sOut ]; } } } 
 class checkLoadmeter extends appmonitorcheck{ public function getGroup(){ return 'monitor'; } protected function _getLoad() { if (function_exists('sys_getloadavg')){ $load = sys_getloadavg(); return $load[0]; } else { if(class_exists('COM')){ $wmi=new COM('WinMgmts:\\\\.'); $cpus=$wmi->InstancesOf('Win32_Processor'); $load=0; if(version_compare('4.50.0', PHP_VERSION) == 1){ while($cpu = $cpus->Next()){ $load += $cpu->LoadPercentage; } }else{ foreach($cpus as $cpu){ $load += $cpu->LoadPercentage; } } return $load; } return false; } } public function run($aParams){ $fLoad=$this->_getLoad(); if($fLoad===false){ $iResult=RESULT_UNKNOWN; } else { $iResult=RESULT_OK; if(isset($aParams['warning']) && $aParams['warning'] && $fLoad>$aParams['warning']){ $iResult=RESULT_WARNING; } if(isset($aParams['error']) && $aParams['error'] && $fLoad>$aParams['error']){ $iResult=RESULT_ERROR; } } return [ $iResult, ($fLoad===false ? 'load value is not available' : 'current load is: '.$fLoad), ($fLoad===false ? [] : [ 'type'=>'counter', 'count'=>$fLoad, 'visual'=>'line', ] ) ] ; } } 
 class checkMysqlConnect extends appmonitorcheck{ public function getGroup(){ return 'database'; } public function run($aParams) { $this->_checkArrayKeys($aParams, "server,user,password,db"); $mysqli=mysqli_init(); if(!$mysqli){ return [RESULT_ERROR, 'ERROR: mysqli_init failed.']; } if (!$mysqli->options(MYSQLI_OPT_CONNECT_TIMEOUT, (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp)) { return [RESULT_ERROR, 'ERROR: setting mysqli_options failed.']; } $db = (isset($aParams["port"]) && $aParams["port"]) ? $mysqli->real_connect($aParams["server"], $aParams["user"], $aParams["password"], $aParams["db"], $aParams["port"]) : $mysqli->real_connect($aParams["server"], $aParams["user"], $aParams["password"], $aParams["db"]) ; if ($db) { $mysqli->close(); return [RESULT_OK, "OK: Mysql database " . $aParams["db"] . " was connected"]; return true; } else { return [ RESULT_ERROR, "ERROR: Mysql database " . $aParams["db"] . " was not connected. Error ".mysqli_connect_errno() .": ". mysqli_connect_error() ]; } } } 
 class checkPdoConnect extends appmonitorcheck{ public function getGroup(){ return 'database'; } public function run($aParams) { $this->_checkArrayKeys($aParams, "connect,user,password"); try{ $db = new PDO( $aParams['connect'], $aParams['user'], $aParams['password'], [ PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_TIMEOUT => (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp, ] ); $db=null; return [RESULT_OK, "OK: Database was connected with PDO " . $aParams['connect']]; } catch(PDOException $e) { return [RESULT_ERROR, "ERROR: Database was not connected " . $aParams['connect'] . " was not connected. Error ".$e->getMessage()]; } } } 
 class checkPhpmodules extends appmonitorcheck{ public function getGroup(){ return 'service'; } public function run($aParams) { $sOut=''; $bHasError=false; $bHasWarning=false; $aAllMods=get_loaded_extensions(false); if(isset($aParams['required']) && count($aParams['required'])){ $sOut.='Required: '; foreach($aParams['required'] as $sMod){ $sOut.=$sMod.'='; if(!array_search($sMod, $aAllMods)===false){ $sOut.='OK;'; } else { $bHasError=true; $sOut.='MISS;'; } } } if(isset($aParams['optional']) && count($aParams['optional'])){ $sOut.=($sOut ? '|' : '') . 'Optional: '; foreach($aParams['optional'] as $sMod){ $sOut.=$sMod.'='; if(!array_search($sMod, $aAllMods)===false){ $sOut.='OK;'; } else { $bHasWarning=true; $sOut.='MISS;'; } } } if($bHasError){ return [RESULT_ERROR, "ERROR: " . $sOut]; } if($bHasWarning){ return [RESULT_WARNING, "WARNING: " . $sOut]; } return [RESULT_OK, "OK: " . $sOut]; } } 
 class checkPing extends appmonitorcheck{ public function getGroup(){ return 'network'; } public function run($aParams) { $sHost = $aParams['host'] ?? '127.0.0.1'; $sParamCount=strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' ? "n" : "c"; $iRepeat=1; $sCommand="ping -$sParamCount $iRepeat $sHost 2>&1"; exec($sCommand, $aOut, $iRc); $sOut=implode("\n", $aOut); if ($iRc>0){ return [RESULT_ERROR, "ERROR: ping to $sHost failed.\n".$sOut]; } return [RESULT_OK, "OK: ping to $sHost\n".$sOut]; } } 
 class checkPortTcp extends appmonitorcheck{ public function getGroup(){ return 'network'; } public function run($aParams) { $this->_checkArrayKeys($aParams, "port"); $sHost = $aParams['host'] ?? '127.0.0.1'; $iPort = (int) $aParams['port']; if (!function_exists('socket_create')){ return [RESULT_UNKNOWN, "UNKNOWN: Unable to perform tcp test. The socket module is not enabled in the php installation."]; } $socket = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP); if ($socket === false) { return [RESULT_UNKNOWN, "ERROR: $sHost:$iPort was not checked. socket_create() failed: " . socket_strerror(socket_last_error())]; } socket_set_option( $socket, SOL_SOCKET, SO_SNDTIMEO, [ "sec"=>(isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp, "usec"=>0 ] ); $result = @socket_connect($socket, $sHost, $iPort); if ($result === false) { $aResult=[RESULT_ERROR, "ERROR: $sHost:$iPort failed. " . socket_strerror(socket_last_error($socket))]; socket_close($socket); return $aResult; } else { socket_close($socket); return [RESULT_OK, "OK: $sHost:$iPort was connected."]; } } } 
 class checkSimple extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "result,value"); $aData=[]; foreach([ 'type', 'count', 'visual' ] as $sMyKey){ if(isset($aParams[$sMyKey])){ $aData[$sMyKey]=$aParams[$sMyKey]; } } return [ $aParams["result"], $aParams["value"], count($aData) ? $aData : false ]; } } 
 class checkSqliteConnect extends appmonitorcheck{ public function getGroup(){ return 'database'; } public function run($aParams) { $this->_checkArrayKeys($aParams, "db"); if (!file_exists($aParams["db"])) { return [RESULT_ERROR, "ERROR: Sqlite database file " . $aParams["db"] . " does not exist."]; } if(!isset($aParams['user'])){ $aParams['user']=''; } if(!isset($aParams['password'])){ $aParams['password']=''; } try { $o = new PDO("sqlite:" . $aParams["db"], $aParams['user'], $aParams['password'], [ PDO::ATTR_TIMEOUT => (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp, ] ); return [RESULT_OK, "OK: Sqlite database " . $aParams["db"] . " was connected"]; } catch (Exception $e) { return [RESULT_ERROR, "ERROR: Sqlite database " . $aParams["db"] . " was not connected. " . $e->getMessage()]; } } } 
 if (!defined('RESULT_OK')) { define("RESULT_OK", 0); define("RESULT_UNKNOWN", 1); define("RESULT_WARNING", 2); define("RESULT_ERROR", 3); } class appmonitorcheck { protected float $_iStart = 0; protected array $_aConfig = []; protected array $_aData = []; protected array $_units = ['B', 'KB', 'MB', 'GB', 'TB']; protected int $_iTimeoutTcp = 5; protected string $_sPluginDir = __DIR__ . '/../plugins'; public function __construct() { } protected function _createDefaultMetadata(): bool { $this->_aData = [ "name" => $this->_aConfig["name"], "description" => $this->_aConfig["description"], "group" => isset($this->_aConfig["group"]) ? $this->_aConfig["group"] : false, "parent" => isset($this->_aConfig["parent"]) ? $this->_aConfig["parent"] : false, "result" => RESULT_UNKNOWN, "value" => false, "type" => false, "time" => false, ]; return true; } protected function _setResult(int $iResult): true { $this->_aData["result"] = (int) $iResult; return true; } protected function _setOutput(string $s): bool { $this->_aData["value"] = $s; return true; } protected function _setCounter(array $aParams): bool { if (is_array($aParams) && count($aParams)) { foreach (['type', 'count', 'visual'] as $sMyKey) { if (isset($aParams[$sMyKey])) { $this->_aData[$sMyKey] = $aParams[$sMyKey]; } } } return true; } protected function _setReturn(int $iResult, string $s, array $aCounter = []) { $this->_setResult($iResult); $this->_setOutput($s); $this->_setCounter($aCounter); return true; } protected function _checkArrayKeys($aConfig, $sKeyList) { foreach (explode(",", $sKeyList) as $sKey) { if (!isset($aConfig[$sKey])) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - array of check parameters requires the keys [$sKeyList] - but key <code>$sKey</code> was not found in config array." . "<pre>" . print_r($aConfig, true) . '</pre>' ); } if (is_null($aConfig[$sKey])) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - key <code>$sKey</code> is empty in config array" . "<pre>" . print_r($aConfig, true) . '</pre>' ); } } return true; } public function makeCheck(array $aConfig): array { $this->_iStart = microtime(true); $this->_checkArrayKeys($aConfig, "name,description,check"); $this->_checkArrayKeys($aConfig["check"], "function"); $this->_aConfig = $aConfig; $this->_createDefaultMetadata(); $sCheck = preg_replace('/[^a-zA-Z0-9]/', '', $this->_aConfig["check"]["function"]); $aParams = $this->_aConfig["check"]["params"] ?? []; $sPluginFile = strtolower($this->_sPluginDir . '/checks/' . $sCheck . '.php'); $sCheckClass = 'check' . $sCheck; if (!class_exists($sCheckClass)) { if (file_exists($sPluginFile)) { } } if (!class_exists($sCheckClass)) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - check class not found: <code>$sCheckClass</code>" . "<pre>" . print_r($aConfig, true) . '</pre>' . "<h2>Known checks</h2>\n" . print_r($this->listChecks(), 1) ); } $oPlugin = new $sCheckClass; $aResponse = $oPlugin->run($aParams); if (!is_array($aResponse)) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - plugin : $sCheck does not responses an array" . "<pre>INPUT " . print_r($aConfig, true) . '</pre>' . "<pre>RESPONSE " . print_r($aResponse, true) . '</pre>' ); } if (count($aResponse) < 2) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " - plugin : $sCheck does not responses the minimum of 2 array values" . "<pre>INPUT " . print_r($aConfig, true) . '</pre>' . "<pre>RESPONSE " . print_r($aResponse, true) . '</pre>' ); } if (!isset($aResponse[2]) || !$aResponse[2]) { $aResponse[2] = []; } $this->_setReturn($aResponse[0], $aResponse[1], $aResponse[2]); if (!$this->_aData['group'] && method_exists($oPlugin, "getGroup")) { $this->_aData['group'] = $oPlugin->getGroup($aParams); } $this->_aData['time'] = number_format((microtime(true) - $this->_iStart) * 1000, 3) . 'ms'; return $this->respond(); } public function listChecks(): array { $aReturn = []; $class = new ReflectionClass($this); foreach ($class->getMethods(ReflectionMethod::IS_PROTECTED) as $oReflectionMethod) { if (strpos($oReflectionMethod->name, "check") === 0) { $aReturn[(string) $oReflectionMethod->name] = 1; } } foreach (glob($this->_sPluginDir . '/checks/*.php') as $sPluginFile) { $aReturn[str_replace('.php', '', basename($sPluginFile))] = 1; } ksort($aReturn); return array_keys($aReturn); } public function respond() { return $this->_aData; } protected function _certGetInfos(string $sUrl, bool $bVerifyCert): array { $iTimeout = 10; $aUrldata = parse_url($sUrl); $sHost = isset($aUrldata['host']) ? $aUrldata['host'] : false; $iPort = isset($aUrldata['port']) ? $aUrldata['port'] : ((isset($aUrldata['scheme']) && $aUrldata['scheme'] === 'https') ? 443 : false); $aSsl = ['capture_peer_cert' => true]; if ($bVerifyCert) { $aSsl['verify_peer'] = false; $aSsl['verify_peer_name'] = false; } ; $get = stream_context_create(['ssl' => $aSsl]); if (!$get) { return ['_error' => 'Error: Cannot create stream_context']; } $errno = -1; $errstr = "stream_socket_client failed."; $read = stream_socket_client("ssl://$sHost:$iPort", $errno, $errstr, $iTimeout, STREAM_CLIENT_CONNECT, $get); if (!$read) { return ['_error' => "Error $errno: $errstr; cannot create stream_socket_client with given stream_context to ssl://$sHost:$iPort; you can try to set the flag [verify] to false to check expiration date only."]; } $cert = stream_context_get_params($read); if (!$cert) { return ['_error' => "Error: socket was connected to ssl://$sHost:$iPort - but I cannot read certificate infos with stream_context_get_params "]; } return openssl_x509_parse($cert['options']['ssl']['peer_certificate']); } protected function _getHrSize(int $size): string { $power = $size > 0 ? floor(log($size, 1024)) : 0; return number_format($size / pow(1024, $power), 2, '.', ',') . ' ' . $this->_units[$power]; } protected function _getSize(string $sValue): int { if (is_int($sValue)) { return $sValue; } $power = 0; foreach ($this->_units as $sUnit) { if (preg_match('/^[0-9\.\ ]*' . $sUnit . '/', $sValue)) { $i = preg_replace('/([0-9\.]*).*/', '$1', $sValue); $iReal = $i * pow(1024, $power); return $iReal; } $power++; } header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' . __METHOD__ . " ERROR in space value parameter - there is no size unit in [$sValue] - allowed size units are " . implode('|', $this->_units) ); } } 
if (!class_exists('appmonitorcheck')) { } class appmonitor { protected string $_sVersion = 'php-client-v0.137'; protected int $_iDefaultTtl = 300; protected int $_iMaxResult = -1; protected array $_aMeta = []; protected array $_aChecks = []; protected float $_iStart = 0; public function __construct() { $this->_createDefaultMetadata(); } protected function _createDefaultMetadata(): bool { $this->_iStart = microtime(true); $this->_aMeta = [ "host" => false, "website" => false, "ttl" => false, "result" => false, "time" => false, "version" => $this->_sVersion, ]; $this->setHost(); $this->setWebsite(); $this->setTTL(); return true; } public function setHost(string $s = ''): bool { if (!$s) { $s = php_uname("n"); } if (!$s) { return false; } $this->_aMeta["host"] = $s; return true; } public function setWebsite($sWebsite = ''): bool { if (!$sWebsite && isset($_SERVER["HTTP_HOST"])) { $sWebsite = $_SERVER["HTTP_HOST"]; } if (!$sWebsite) { return false; } $this->_aMeta["website"] = $sWebsite; return true; } public function setTTL($iTTl = 0) { if ($iTTl == 0) { $iTTl = $this->_iDefaultTtl; } return $this->_aMeta["ttl"] = $iTTl; } public function setResult(int $iResult = -1): bool { if ($iResult === -1) { $iResult = $this->_iMaxResult; } $this->_aMeta["result"] = $iResult; return true; } public function addCheck($aJob = []): bool { $oCheck = new appmonitorcheck(); $aCheck = $oCheck->makecheck($aJob); $iMyResult = isset($aJob['worstresult']) ? min($aCheck["result"], $aJob['worstresult']) : $aCheck["result"] ; if (!$this->_iMaxResult || $iMyResult > $this->_iMaxResult) { $this->_iMaxResult = $iMyResult; } $this->_aChecks[] = $aCheck; return true; } protected function _addNotification(string $sType, string $sValue, string $sKey = ''): bool { $sTypeCleaned = preg_replace('/[^a-z]/', '', strtolower($sType)); if (!isset($this->_aMeta['notifications'])) { $this->_aMeta['notifications'] = []; } if (!isset($this->_aMeta['notifications'][$sTypeCleaned])) { $this->_aMeta['notifications'][$sTypeCleaned] = []; } if ($sKey) { $this->_aMeta['notifications'][$sTypeCleaned][$sKey] = $sValue; } else { $this->_aMeta['notifications'][$sTypeCleaned][] = $sValue; } return true; } public function addEmail(string $sEmailAddress) { return $this->_addNotification('email', $sEmailAddress); } public function addSlackWebhook(string $sLabel, string $sSlackWebhookUrl): bool { return $this->_addNotification('slack', $sSlackWebhookUrl, $sLabel); } public function addTag(string $sTag): bool { if (!isset($this->_aMeta['tags'])) { $this->_aMeta['tags'] = []; } $this->_aMeta['tags'][] = str_replace(' ', '_', $sTag); return true; } public function checkIp(array $aAllowedIps = []): bool { if (!isset($_SERVER['REMOTE_ADDR']) || !count($aAllowedIps)) { return true; } $sIP = $_SERVER['REMOTE_ADDR']; foreach ($aAllowedIps as $sIp2Check) { if (strpos($sIP, $sIp2Check) === 0) { return true; } } header('HTTP/1.0 403 Forbidden'); die('ERROR: Your ip address [' . $sIP . '] has no access.'); } public function checkToken(string $sVarname, string $sToken): bool { if (!isset($_GET)) { return true; } if (isset($_GET[$sVarname]) && $_GET[$sVarname] === $sToken) { return true; } header('HTTP/1.0 403 Forbidden'); die('ERROR: A token is required.'); } public function listChecks(): array { $oCheck = new appmonitorcheck(); return $oCheck->listChecks(); } protected function _checkData(): bool { $aErrors = []; if (!count($this->_aChecks)) { $aErrors[] = "No checks have been defined."; } if ($this->_aMeta["result"] === false) { $aErrors[] = "method setResult was not used to set a final result for all checks."; } if (count($aErrors)) { $this->abort( '<h2>Error: client check is not complete</h2><p>Found errors:</p><ol><li>' . implode('<li>', $aErrors) . '</ol><br><br>' ); } return true; } public function abort(string $sMessage): void { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . $sMessage); } public function getResults(): array { return [ "meta" => $this->_aMeta, "checks" => $this->_aChecks, ]; } public function render(): string { $this->_checkData(); $this->_aMeta['time'] = number_format((microtime(true) - $this->_iStart) * 1000, 3) . 'ms'; $sOut=json_encode($this->getResults()); header('Content-type: application/json'); header('Cache-Control: cache'); header('max-age: ' . $this->_aMeta["ttl"]); echo $sOut; return $sOut; } public function renderHtmloutput(string $sJson): string { header('Content-type: text/html'); header('Cache-Control: cache'); header('max-age: ' . $this->_aMeta["ttl"]); $aMsg = [ 0 => "OK", 1 => "UNKNOWN", 2 => "WARNING", 3 => "ERROR" ]; $aData = json_decode($sJson, 1); $sOut = ''; $sOut .= '' . '<h2>Metadata</h2>' . '<div class="meta' . (isset($aData['meta']['result']) ? ' result' . $aData['meta']['result'] : '') . '">' . 'Status: ' . (isset($aData['meta']['result']) ? $aMsg[$aData['meta']['result']] : '?') . '<br>' . '</div>' . 'Host: ' . (isset($aData['meta']['host']) ? '<span class="string">' . $aData['meta']['host'] . '</span>' : '?') . '<br>' . 'Website: ' . (isset($aData['meta']['website']) ? '<span class="string">' . $aData['meta']['website'] . '</span>' : '?') . '<br>' . 'Execution time: ' . (isset($aData['meta']['time']) ? '<span class="float">' . $aData['meta']['time'] . '</span>' : '?') . '<br>' . 'Client: ' . (isset($aData['meta']['version']) ? '<span class="string">' . $aData['meta']['version'] . '</span>' : '?') . '<br>' . '<h2>Checks</h2>' ; if (isset($aData['checks'][0]) && count($aData['checks'])) { foreach ($aData['checks'] as $aCheck) { $sOut .= '' . '<span class="result' . $aCheck['result'] . '"> <strong>' . $aCheck['name'] . '</strong></span> <br>' . '<div class="check">' . '<div class="description">' . $aCheck['description'] . '<br>' . $aCheck['value'] . '<br>' . '</div>' . 'Execution time: <span class="float">' . (isset($aCheck['time']) ? $aCheck['time'] : ' - ') . '</span><br>' . 'Group: <span class="string">' . (isset($aCheck['group']) ? $aCheck['group'] : '-') . '</span><br>' . 'parent: <span class="string">' . (isset($aCheck['parent']) ? $aCheck['parent'] : '-') . '</span><br>' . 'Status: ' . $aMsg[$aCheck['result']] . '<br>' . '</div>' ; } } $sOut .= '<h2>List of farbcodes</h2>'; foreach ($aMsg as $i => $sText) { $sOut .= '<span class="result' . $i . '">' . $sText . '</span> '; } $sRaw=json_encode($aData, JSON_PRETTY_PRINT); $sRaw = preg_replace('/:\ \"(.*)\"/U', ': "<span class="string">$1</span>"', $sRaw); $sRaw = preg_replace('/:\ ([0-9]*)/', ': <span class="int">$1</span>', $sRaw); $sRaw = preg_replace('/\"(.*)\":/U', '"<span class="key">$1</span>":', $sRaw); $sOut .= '<h2>Raw result data</h2><pre id="raw">' . $sRaw . '</pre>'; $sOut = '<!DOCTYPE html><html><head>' . '<style>' . 'body{background:#eee; color:#444; font-family: verdana,arial; margin: 0; }' . 'body>div#content{background: #fff; border-radius: 2em; border: 4px solid #abc; box-shadow: 0.5em 0.5em 2em #aaa; margin: 2em 10%; padding: 2em;}' . 'h1{color:#346; margin: 0;}' . 'h2{color:#569; margin-top: 2em;}' . 'pre{background:#f4f4f8; padding: 1em; overflow-x:auto; }' . '#raw .key{color:#808;}' . '#raw .int{color:#3a3; font-weight: bold;}' . '#raw .string{color:#66e;}' . '.check{border: 1px solid #ccc; padding: 0.4em; margin-bottom: 2em;}' . '.description{font-style: italic; padding: 0.4em 1em;}' . '.float{color:#080;}' . '.meta{margin-bottom: 1em;}' . '.result0{background:#aca; border-left: 1em solid #080; padding: 0.5em; }' . '.result1{background:#ccc; border-left: 1em solid #aaa; padding: 0.5em; }' . '.result2{background:#fc9; border-left: 1em solid #860; padding: 0.5em; }' . '.result3{background:#f88; border-left: 1em solid #f00; padding: 0.5em; }' . '.string{color:#338;}' . '</style>' . '<title>' . __CLASS__ . '</title>' . '</head><body>' . '<div id="content">' . '<h1>' . __CLASS__ . ' :: client status</h1>' . $sOut . '</div>' . '</body></html>'; return $sOut; } } 